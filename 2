static int fs_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    dirEntry* file = NULL;                     // file to read
    unsigned short block = 0;                  // first block of the file
    unsigned int fileSize = 0;                 // size of the file
    unsigned int bytesRead = 0;                // number of bytes read
    unsigned int bytesToRead = 0;              // number of bytes to read
    unsigned int blockOffset = 0;              // offset within the block
    char* localpath = strdup(path);            // duplicate the path for manipulation

    // check if the file system is loaded
    fsLoadedCheck();

    // find the file to read
    file = findEntryFromPath(localpath, fuseRoot);

    // check if the file exists
    if (file == NULL) {
        free(localpath);
        return -ENOENT;
    }

    // check if the file is a directory
    if (file->attributes == ATTR_DIRECTORY) {
        free(localpath);
        return -EISDIR;
    }

    // get the file's size and first block
    fileSize = file->size;
    block = file->first_cluster_low;

    // check if offset is beyond file size
    if (offset >= fileSize) {
        free(localpath);
        return 0;
    }

    // adjust size if read goes beyond file size
    if (offset + size > fileSize) {
        size = fileSize - offset;
    }

    // navigate to the correct block based on the offset
    while (offset >= BLOCKSIZE) {
        block = FAT[block];
        offset -= BLOCKSIZE;
    }

    blockOffset = offset; // offset within the block
    bytesRead = 0;

    // read data block by block
    while (size > 0) {
        bytesToRead = (size > (BLOCKSIZE - blockOffset)) ? (BLOCKSIZE - blockOffset) : size;
        memcpy(buf + bytesRead, blocks[block].data + blockOffset, bytesToRead);
        size -= bytesToRead;
        bytesRead += bytesToRead;
        blockOffset = 0; // reset block offset for subsequent reads

        // move to the next block if necessary
        if (size > 0) {
            block = FAT[block];
            if (block == USHRT_MAX) {
                break;
            }
        }
    }

    free(localpath);
    return bytesRead;
}
